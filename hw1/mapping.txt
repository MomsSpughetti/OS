


time_out command:
	recieve a new timeOut command -> Build_in_command ->:
		if(external)
			use fork + execv() to start the given command ->
			
			if(&)
				add the newCommand to the timeOut list (it should have timestamp, duration, pid)
			else()
				nothing
		
		else()
			like jobs - it works in foreground
	THE JUICE:
		how to time the moment of sending SIGKILL?
	#include <unistd.h>
       unsigned int alarm(unsigned int seconds);
       
        it sends the signal to the calling process, so:
       		*use alarm(secondes) syscall in the exec() function of timeOut command (before execv()?)
       	
       		how to know the process to send SIGKILL to?
       			using the list data member of timeOut command obviously! but how?
       			maybe by sorting the list by the finish time (timestamp + duration)
       			so we always should send to the first process in the list when receiving a SIGALRM
       			(is it always working?)
       			in case of Built_in_command do not send SIGKILL(killing the smash itself),is it even applicable?
       			in case of foreground external process, just like before, it will get SIGALRM in the right time 
       			if it was in the list.
       	 
       		





jobs list:
	add vector to smash
	add process to vector if:
		process is stopped using ctrl+z
		process is a background process (only external)
jobs command:
	print the vector ordered by job-id
Note: before any operation - delete the finished jobs from vector!

questions:
	Q: where to add the jobs vector?
	A: in smash class
	Q: when to use fork other than in external commands?
	A: for example when using pip. Mohamad
	Q: how to pass signal to the current process (signals are sent to 'main' process)?
	A: using kill syscall. Mohamad
	Q: how to print vector in order?
	A: According to the job ID. Mohamad
	Q: when and where to delete finished jobs?
	A: finished jobs should be deleted in every while loop in main function
	Q: what should the vector contain?
	A: job objects (provided)

notes to M1:
	deleteing finished jobs should be done before moving to next loop (in main).
	- yes, in addition we need to delete them before calling many functions, we will discuse that 
	when we review the code.
	shouldn't PID be a data member of command class? and from where PID value is set?
	- no, command will get deleted before getting into the next command to execute
		(there are work arounds, but that's working for now),jobs in the other hand are maintained until they finish or terminat.
	why calling je->run() after 'kill(targetPID, SIGCONT)' (in backgroundCommand::execute())? shouldn't that be in handler code?
	- faliure of kill() might cause a problem.
	should add the print line if succeeded in kill command execute().
	- The code need much more improvment, I cared about a semi-working version as early as possible.

To add:
	data member for smallShell class: 'Command *CurrCommand'. Then we can do whatever we want to the foreground process when main gets a signal!
	signal handlers
	
	
		
problems:
	bg - (removeFinished is removing the process that gets SIGCONT)
	new one: sleep 10 -> sigstop -> sigcont - but sleep still finishes at 10 - if sigcont was sent besfore 10 - else
	it will finishes immediatly!
	redirection command - fork() inside fork() - smash is written when it's not should be (solved)
	|& in pipe ... how you should handle the existence of &
	
	




